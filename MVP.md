# Architectural pattern - service oriented MVP
## Folder Structure
**Core**: The implementation of the core app parts, i.e. the business logic of the app
- App Delegate/Scene Delegate
- networking
- services
- modules
- etc

**Data**: Data models are divided into *models* (storing data; are separated into database models and POSO models) and *types* (identifying data).

**Custom UI**: All custom UI elements.

**Common**: Code pieces (not fitting into other folders) that are reused in numerous parts of the project (cells, parent view controllers/presenters, custom tabbar and navigation controllers etc.)

**Flows**: Modules of the app. Modules should also be subgrouped, depending on context (e.g. `Authorization` folder containing `Login`, `Registration`, `Forgot Password` modules).

**Misc**: All auxiliary code (protocols, extensions, helpers etc.) + files with access to default values (`Constants.swift`) and backend endpoints (`API.swift`)

**Generated**: Code generated by Swiftgen.

**Resources**: `Info.plist`, custom fonts, assets, strings etc.

## MVP

App is divided into modules (typically, 1 screen equals 1 module). Each module consists of:

**Presenter**: main decision-maker of the module in terms of business logics. Does next to zero work by itself, delegates everything to services, commands view when and what to update. Main goal is tasks distribution.

**View Controller + xib**: UI layer of the module. On one hand, it’s as thin as possible (all and any user action is delegated to the presenter), on the other hand view controller decides HOW to present the data (this includes formatting, animations etc.)

**Router**: performs navigation between modules

**Cells (.swift + .xib)** (if any): are a part of the module. If same cell is reused in other modules, it is moved to the `Common` folder. If the cell is complex, it can be implemented as a module itself. In simpler cases, it’s just a single .swift file (+ .xib).

### Relations between module parts:

- Presenter stores weak link to view controller (hidden under `<_ModuleName_Interface>` protocol)
- Presenter stores strong link to router (hidden under `<_ModuleName_RouterProtocol>` protocol)
- Presenter stores strong links to services (each hidden under protocol)
- View Controller stores strong link to presenter (hidden under `<_ModuleName_Output>` protocol)
- Router stores weak link to view controller (property type is`UIViewController`)

Given that no one stores a strong link to view controller, there is a requirement to display the controller right after the module creation, so that `UIKit` persists it. If the presenter will be stored in some property and view controller will not be displayed, all module parts will be released right after leaving the scope. 
For this purpose (storing module as a pair of presenter+view controller until it needs to be displayed) the `Module` type has been introduced. For consistency reasons it is used even when such behavior is not required.
```swift
class Module<PresenterType, InterfaceType> {
    
    private(set) var presenter: PresenterType
    private(set) var interface: InterfaceType
    
    init(presenter: PresenterType, interface: InterfaceType) {
        self.presenter = presenter
        self.interface = interface
    }
}
```

All modules are created through `Modules` factory-like class. It can create modules of its own and also stores other factory-like classes to create modules for a specific app part. 

```swift
class Modules {
	
    private let services = Services.shared
    
    // MARK: - Singleton
    
    static let shared: Modules = Modules()
    private init() {}
    
    // MARK: - Public
    
    func makeSplashModule() -> Module<SplashPresenter, UIViewController> {
        let viewController = SplashViewController()
        let router = SplashRouter(with: viewController)
        let presenter = SplashPresenter(withView: viewController, router: router, loginService: services.makeAuthorizationService())
        viewController.presenter = presenter
        
        return Module(presenter: presenter, interface: viewController)
    }
}
```

All services are created through `Services` facroty-like class.

```swift
class Services {
    
    private lazy var authorizationService = AuthorizationService(networkService: makeNetworkService(), 
			keychainService: makeKeychainService(), 
			databaseService: makeDatabaseService())
    
    // MARK: - Singleton
    
    static let shared: Services = Services()
    private init() {}
    
    // MARK: - Public
    
    func makeAuthorizationService() -> LoginProtocol & RegistrationProtocol {
        return authorizationService
    }
    
    func makeUserService() -> UserServiceProtocol {
        return UserService(params)
    }
	
	// MARK: - Private 
    
    private func makeNetworkService() -> Networking {
        return NetworkService(errorParser: makeErrorParser())
    }
	...
}
```

These 2 classes (`Modules` and `Services`) are ideally the only 2 singletons in the project. If any service needs to have a singleton-like behavior, it can be achieved by 
- passing the instance of the service between modules
- storing the instance of the service as a property inside `Services` (see `authorizationService` above) 

### Other Conventions

- The project is localized regardless of the number of supported languages. Adding a new language is thus a matter of adding 1 .strings file in the future.
- All texts are set in code. Xibs are not localized. Each view controller (if it has texts at all) has a `setupTexts()` method which is called from `viewDidLoad`.
- Xibs are used instead of storyboards for a number of reasons (e.g. better functionality separation, support for dependency injection, convenient initialization)

## Code generation
Swiftgen - https://github.com/SwiftGen/SwiftGen
Code is auto-generated for:
- Localizable strings
- xcassets (this includes both images and colors)
- Fonts

Generated code files are stored in `Generated` folder.

## Code formatting 
Swiftlint - https://github.com/realm/SwiftLint
